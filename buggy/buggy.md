# Buggy!

这里列举一些奇怪的bug，帮助深入理解一些rust语法。

### Arc? into_raw()? 泄漏了！

`Arc/Rc` 是rust中常用的智能指针类，进行引用计数，提供类似C++ `shared_ptr`的功能。区别在于 `Arc`（atomic reference counting) 确保操作原子性, 可被多线程程序使用。 

引用计数的原理是，对一块内存，只用“智能指针”对它进行访问，并记录有多少智能指针指向这块内存。当计数器归零时，认为这块内存已经不再被使用。

这段代码演示了引用计数的变化
```rust
use std::sync::Arc;
struct aha{
 inner:[i32;5],
}
fn main(){
        let a = Arc::new(aha{inner:[0;5]});
        println!("{}",Arc::strong_count(&a));//1
        let b = a.clone();//构造指向同一块内存的引用。可以用来作为函数的参数。
        println!("{}",Arc::strong_count(&a));//2
        drop(a);//手动释放一个引用
        println!("{}",Arc::strong_count(&b));//1
}//在b离开作用域之后，引用数归零，内存被释放
```
这里我们调用的函数叫做`strong_count`, 与之对应，就有一个`weak_count`
 
在C++中，为了解决`shared_ptr`的“循环引用”问题，引入了一种指针叫做`weak_ptr`。

什么是循环引用？就是结构体A拿着一个指针指向结构体B，使得B的引用计数增加1；结构体B拿着一个指针指向结构体A，使得A的引用计数增加1，此时就不能依赖“引用计数归零时内存自动释放”。

对于一个使用智能指针(shared_ptr/Rc)的单向链表，所有的指针都是前向的，如果我们手工释放掉第一个节点，后面的第二个节点就会引用计数归零从而释放，然后导致第三个节点引用计数归零释放......如多米诺骨牌全都释放完毕，非常方便，省去了我们自己遍历链表释放所有节点的麻烦。

但对于双向链表这样的数据结构，手工释放受节点之后，之后的节点会无动于衷：第二个节点还被第三个节点引用着。
