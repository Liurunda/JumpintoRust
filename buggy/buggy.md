# Buggy!

这里列举一些奇怪的bug，帮助深入理解一些rust语法。

### Arc? into_raw()? 泄漏了！

`Arc/Rc` 是rust中常用的智能指针类，进行引用计数，提供类似C++ `shared_ptr`的功能。区别在于 `Arc`（atomic reference counting) 确保操作原子性, 可被多线程程序使用。 

引用计数的原理是，对一块内存，只用“智能指针”对它进行访问，并记录有多少智能指针指向这块内存。当计数器归零时，认为这块内存已经不再被使用。

这段代码演示了引用计数的变化
```rust
use std::sync::Arc;
struct aha{
 inner:[i32;5],
}
fn main(){
        let a = Arc::new(aha{inner:[0;5]});
        println!("{}",Arc::strong_count(&a));//1
        let b = a.clone();//构造指向同一块内存的引用。可以用来作为函数的参数。
        println!("{}",Arc::strong_count(&a));//2
        drop(a);//手动释放一个引用
        println!("{}",Arc::strong_count(&b));//1
}//在b离开作用域之后，引用数归零，内存被释放
```
这里我们调用的函数叫做`strong_count`, 与之对应，就有一个`weak_count`
 
在C++中，为了解决`shared_ptr`的“循环引用”问题，引入了一种指针叫做`weak_ptr`。

什么是循环引用？就是结构体A拿着一个指针指向结构体B，使得B的引用计数增加1；结构体B拿着一个指针指向结构体A，使得A的引用计数增加1，此时就不能依赖“引用计数归零时内存自动释放”。

对于一个使用智能指针(shared_ptr/Rc)的单向链表，所有的指针都是前向的，如果我们手工释放掉第一个节点，后面的第二个节点就会引用计数归零从而释放，然后导致第三个节点引用计数归零释放......如多米诺骨牌全都释放完毕，非常方便，省去了我们自己遍历链表释放所有节点的麻烦。

但对于双向链表这样的数据结构，手工释放受节点之后，之后的节点会无动于衷：第二个节点还被第三个节点引用着。

如何让双向链表实现“删除首节点后，垃圾回收机制自动回收剩余节点”呢？我们可以想象这么一种指针：可以通过它来访问一个对象，但是不会让引用计数加一......听起来就像产生智能指针之前的“裸指针”一样。但是直接用裸指针毕竟不太好看，我们可以将这种指针称之为“弱指针、弱引用”，对应C++中的`weak_ptr`或rust中的`Weak`

在rust中，对于智能指针指向的一个结构体（这个结构体位于一块内存中），维护两个计数器: `strong_count`和`weak_count`, `strong_count`归零时即可调用`drop()`函数，`strong_count`和`weak_count`都归零的时候将可以释放这块内存。

对于`Rc`和`Weak`智能指针，都有一个`into_raw()`函数可以获取对应的裸指针，但是必须之后调用一次unsafe的`from_raw()`把裸指针转换回来，否则会导致内存泄漏。因为引用计数的减一是在`Rc`或`Weak`结构体离开作用域或被手动调用`drop`时发生的，而`into_raw()`并不会导致引用计数的变化。

`Arc_raw_leak`程序中演示了`into_raw()`的指针未被转换回来导致的内存泄漏。我们使用了rust社区中的一个带调试信息的内存分配器（by @Yandros），用来展示内存泄漏的bug。注意完全有可能一个结构体被调用了`drop()`函数但它占用的内存却没被释放。
